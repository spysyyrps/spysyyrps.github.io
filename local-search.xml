<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/hello-world/"/>
    <url>/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>neo4j的导入与导出</title>
    <link href="/neo4j%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/"/>
    <url>/neo4j%E7%9A%84%E5%AF%BC%E5%85%A5%E4%B8%8E%E5%AF%BC%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><p>&nbsp;</p><blockquote><p>本文主要介绍neo4j的导入（import,load）和导出（export）,基本是基于csv和dump文件格式。将会介绍在终端和使用apoc利用Cypher语言两种情况如何实现导入导出,同时也会大致讲讲所需的csv文件的格式。并且所有的导入导出操作都是在终端或neo4j浏览器界面，并未使用编程语言。</p></blockquote><p>&nbsp;</p><p>我的版本配置：</p><blockquote><ul><li><strong>操作系统</strong>:<strong>ubuntu22.04</strong></li><li><strong>neo4j</strong><strong>server</strong>:<strong>5.10.0社区版</strong></li><li><strong>apoc-core</strong>:<strong>5.10.1</strong>(这是个neo4j插件，之后会讲到)</li></ul></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="1-终端下导入导出"><a href="#1-终端下导入导出" class="headerlink" title="1. 终端下导入导出"></a>1. 终端下导入导出</h2><p>（ubuntu ctrl +alt +T 打开终端）。</p><p>与neo4j相关的命令基本是以<strong>neo4j</strong>,<strong>neo4j-admin</strong>或者<strong>neo4j-admin server</strong>开头，三者在后面添加 <code>-h</code>都可以查看其帮助文档。</p><p><img src="https://s2.loli.net/2023/08/09/vNZE4nUGx9Ck3Ba.png"></p><p>而我们需要的命令就是<strong>neo4j-admin database</strong></p><p>我们使用 <code>neo4j-admin database -h</code>来查看<strong>neo4j-admin database</strong>的使用方法。</p><p><img src="https://s2.loli.net/2023/08/09/ZR2kAgm3IWtoMwj.png"></p><p>而我们要用的就是<strong>dump</strong>,<strong>load</strong>,<strong>import</strong></p><p>&nbsp;</p><h3 id="dump"><a href="#dump" class="headerlink" title="dump"></a><a href="https://neo4j.com/docs/operations-manual/current/backup-restore/offline-backup/">dump</a></h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 其中&lt;&gt;是必填选项其余的[]是非必填# 可以使用neo4j-admin database dump -h查看各参数详细信息# 效果是将neo4j的数据导出为一个dump文件，或者一个标准输出流进入类似load的命令neo4j-admin database dump [-h] [--expand-commands]                          [--verbose] [--overwrite-destination[&#x3D;true|false]]                          [--additional-config&#x3D;&lt;file&gt;]                          [--to-path&#x3D;&lt;path&gt; | --to-stdout]                          &lt;database&gt;                # --verbose: 加上后会在执行过程中输出详细的过程，方便了解其过程查看可能的错误点# --overwrite-destination: 如果做后dump文件位置存在同名文件，是否覆盖，默认是false# --to-path&#x3D;&lt;path&gt;： 指定输出文件夹地址。注意！path必须为文件夹地址# --to-stdout: 让输出成为标准输出流而不是一个dump文件</code></pre></div></figure><p>&nbsp;</p><p>其中，如果你命令中既没有 <code>--to-path</code>也没有 <code>--to-stdout</code>，那么，它将会采用Configuration文件（<a href="https://neo4j.com/docs/operations-manual/current/configuration/file-locations/">各操作系统下的neo4j默认文件地址</a>）中的 <code>server.directories.dumps.root</code>设置。</p><p>该设置值是一个文件路径，指dump文件存放的地址。</p><p>如果是相对路径，则是以 <strong>neo4j主目录&#x2F;data&#x2F;<strong>为基准的相对路径。例如 <code>server.directories.dumps.root</code>的默认值就是</strong>dumps</strong>，即如果你命令中既没有 <code>--to-path</code>也没有 <code>--to-stdout</code>，该命令将会在 <strong>neo4j主目录&#x2F;data&#x2F;dumps&#x2F;</strong> 下生成一个dump文件。</p><blockquote><p><em>如果使用 <code>neo4j-admin database dump</code>来导出数据，要确保neo4j数据库处于stop状态</em></p><p><em><code>neo4j status</code>查看当前neo4j运行状态</em></p></blockquote><p>&nbsp;</p><h3 id="load"><a href="#load" class="headerlink" title="load"></a><a href="https://neo4j.com/docs/operations-manual/current/backup-restore/restore-dump/">load</a></h3><p><strong>load</strong>方法主要就是将<strong>dump</strong>导出的 <em>dump文件</em> 或者 <em>标准输出流</em> 中的数据重新导入neo4j数据库中。所以，load+dump就可以实现neo4j的<strong>离线备份</strong>。</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># load和dump的Options大同小异，# 同样的，如果既没有--from-path，又没有--from-stdin，会采用server.directories.dumps.rootneo4j-admin database load [-h] [--expand-commands] [--info] [--verbose][--overwrite-destination[&#x3D;true|false]][--additional-config&#x3D;&lt;file&gt;] [--from-path&#x3D;&lt;path&gt; | --from-stdin] &lt;database&gt;# 有一个特殊的Option --info# 如果你加上了这个选项，那么这个命令将不会将数据导入到neo4j数据库中# 而是打印出这个数据的详细信息# example$ sudo neo4j-admin database load --from-path&#x3D;&#x2F;home&#x2F;mmy intelligentmedicine.db --verbose# 这里由于没选覆盖选项是新建一个数据库为intelligentmedicine.db# 注意！path只要写到dump文件所在的文件夹就行，dump文件必须是&lt;databasename&gt;.dump# 这里就是 intelligentmedicine.db.dump</code></pre></div></figure><p>&nbsp;</p><p><em>与dump有些不同的是，load支持neo4j在线和离线状态的导入（付费版），但是两种都有要注意的地方</em></p><ol><li>如果你打算覆盖原有的数据库，即–overwrite-destination设置成了true，那么你<strong>一定</strong>要先<strong>stop</strong>再执行load语句。</li><li>如果你打算新建一个数据库来存储你load的数据，那么无需离线，但是在<strong>load之后一定要create一个新的database</strong>。</li><li><strong>社区版</strong>的neo4j不支持在线导入，只能关闭服务后导入（付费版没试，但是官方文档说load支持online，应该是指付费版）</li><li><strong>社区版</strong>的load不支持<strong>增量导入</strong>，即要么覆盖要么新建数据库，不能在原有数据上加入。（付费版没试，不知道行不行）</li></ol><blockquote><p><a href="https://neo4j.com/docs/cypher-manual/current/administration/databases/">neo4j创建数据库官方文档</a></p><p>ps: 社区版即免费的neo4j是<strong>只允许一个database</strong>，但是我们可以通过修改配置文件来实现<strong>多个</strong>database共存。但是也有缺点，每次切换数据库要restart，并且修改配置文件（这个简单，就加个#，删个#）。如果有空会分享一下。</p></blockquote><p>&nbsp;</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a><a href="https://neo4j.com/docs/operations-manual/current/tutorial/neo4j-admin-import/">import</a></h3><blockquote><p><em>The import command is used for loading large amounts of data from CSV files and supports full and incremental import into a running or stopped Neo4j DBMS.</em></p><p>上述是官方原话，但是测试发现社区版import只支持全量导入（full）并且只能离线，可能付费才能增量与在线导入。</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># Usage: neo4j-admin database import [-h] [COMMAND]# example$ sudo neo4j-admin database import full --verbose --overwrite-destination&#x3D;true --nodes &#x2F;home&#x2F;mmy&#x2F;forimport_movie_nodes.csv  --nodes &#x2F;home&#x2F;mmy&#x2F;forimport_person_nodes.csv  --relationships &#x2F;home&#x2F;mmy&#x2F;forimport_rels.csv  test.db</code></pre></div></figure><p> &nbsp;</p><h4 id="csv格式"><a href="#csv格式" class="headerlink" title="csv格式"></a>csv格式</h4><p>import命令本身并没有什么好说的，我们来聊聊导入所需的csv文件格式。</p><h5 id="a-存储nodes的csv文件"><a href="#a-存储nodes的csv文件" class="headerlink" title="a.存储nodes的csv文件"></a>a.存储nodes的csv文件</h5><p><strong>表头（header）</strong></p><ul><li>表头格式&lt;name&gt;:&lt;field_type&gt;</li><li>label在表头并非必须，但是id一定要有</li><li>如果你不想让id加入你的属性值，可以不给它属性名（name），即把下表的movieid去掉。</li></ul><table><thead><tr><th>movieid:ID</th><th>year:int</th><th>:LABEL</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><ul><li>但是如果是增量或者批量导入，规则就有点复杂。<strong>主键的属性必须是标签与属性的结合</strong></li></ul><table><thead><tr><th>uuid:ID{label:Person}</th><th>name:STRING{label:Person}</th><th>email:STRING</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>在这里，<strong>uuid</strong>和n<strong>ame共同做主键</strong>区分节点，并且指定节点导入的<strong>label</strong>为<strong>Person</strong></p><p><strong>这一措施，主要是防止增量导入和批量导入时创建多个重复节点。</strong></p><p>&nbsp;</p><h5 id="b-存储relationship的csv文件"><a href="#b-存储relationship的csv文件" class="headerlink" title="b.存储relationship的csv文件"></a>b.存储relationship的csv文件</h5><p><strong>表头</strong></p><p>存储关系的表头必须包含**:START_ID<strong>，</strong>:END_ID<strong>和</strong>:TYPE<strong>。其中前两个分别对应着关系的</strong>起始实体<strong>和</strong>结束实体<strong>的</strong>:ID<strong>，这就是为什么实体id是必须的。而</strong>:TYPE**是指明这个关系的类型。</p><p>当然，关系也可以有属性，下图便是给关系增加了一个<strong>role</strong>属性</p><table><thead><tr><th>：START_ID</th><th>:END_ID</th><th>:TYPE</th><th>role</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p>&nbsp;</p><blockquote><p><strong>总结</strong>：在社区版，如果使用终端的方法，我们都无法实现在线操作与增量导入。而官方其实还有一种方法，使用Cypher命令load csv可以实现在线导入数据，csv文件地址可以是url形式。(<a href="https://neo4j.com/developer/guide-import-csv/)%E5%A4%A7%E5%AE%B6%E5%8F%AF%E4%BB%A5%E8%87%AA%E8%A1%8C%E6%9F%A5%E7%9C%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%8C%E6%9C%89%E6%A0%B7%E4%BE%8B%E5%8D%81%E5%88%86%E8%AF%A6%E7%BB%86%E3%80%82">https://neo4j.com/developer/guide-import-csv/)大家可以自行查看官方文档，有样例十分详细。</a></p></blockquote><p>&nbsp;</p><p>&nbsp;</p><h2 id="2-利用apoc插件在线导出"><a href="#2-利用apoc插件在线导出" class="headerlink" title="2. 利用apoc插件在线导出"></a>2. 利用apoc插件在线导出</h2><hr><p><a href="https://neo4j.com/docs/apoc/current/">apoc-core</a></p><p><a href="https://neo4j.com/labs/apoc/5/">apoc-extended</a></p><p><a href="https://neo4j.com/docs/apoc/current/export/">apoc_export</a></p><p>apoc在neo4j 5.0之后分为apoc-core和apoc-extended两部分。前者是neo4j官方支持，后者由社区维护。</p><p>而由于apoc-extended最新只有5.9版本，作者neo4j为5.10.x，所以下文只使用了apoc-core。而extended在导入导出方面增加了可使用exel导入导出，可以导入html格式的数据，多样化导入csv文件。</p><p>apoc本质是一个插件，其内容十分丰富，远不止导入导出数据那么简单，大家如有需要可以查看上方的官方文档。</p><p>&nbsp;</p><h3 id="2-1-apoc的安装与配置"><a href="#2-1-apoc的安装与配置" class="headerlink" title="2.1 apoc的安装与配置"></a>2.1 apoc的安装与配置</h3><p>apoc默认状态下并未安装，所以我们要先安装。</p><h4 id="apoc-core的安装"><a href="#apoc-core的安装" class="headerlink" title="apoc-core的安装"></a>apoc-core的安装</h4><p>这个十分简单，在**$NEO4J_HOME&#x2F;labs**文件夹（NEO4J_HOME表示neo4j主目录）中，你会找到一个jar文件。</p><p><img src="https://s2.loli.net/2023/08/09/RACvOsangpDluyX.png" alt="image-20230808103615755"></p><p>将这个文件复制到**$NEO4J_HOME&#x2F;plugins<strong>文件夹下，</strong>apoc-core**就算安装好了！</p><h4 id="apoc-core配置"><a href="#apoc-core配置" class="headerlink" title="apoc-core配置"></a>apoc-core配置</h4><p>a.首先，找到你的neo4j配置文件<strong>neo4j.conf</strong>，neo4j各文件在各操作系统的地址官方文档给出了，链接在前文。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 寻找并修改以下设置，推荐复制粘贴原有的然后去掉注释的#，再修改，方便之后还原默认设置# 放宽apoc权限dbms.security.procedures.unrestricted&#x3D;apoc.*,algo.*# 将apoc的全部都加入allowlistdbms.security.procedures.allowlist&#x3D;apoc.*,apoc.coll.*,apoc.load.*,gds.*</code></pre></div></figure><p>b.之后在neo4j.conf同文件夹下创建一个apoc.conf文件，这个是apoc的配置文件，是要自己手动创建的。</p><figure><div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 加入下面三条设置# 开启文件导出功能apoc.export.file.enabled&#x3D;true# 开启文件导入功能apoc.import.file.enabled&#x3D;true# 指明是否使用 neo4j.conf 指定的相关（导入导出涉及的）目录(默认就是 true)apoc.import.file_use_neo4j_config&#x3D;true</code></pre></div></figure><p>&nbsp;</p><p>好了，接下来我们就可以使用apoc-core来导入导出了。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="2-2-导出为csv文件"><a href="#2-2-导出为csv文件" class="headerlink" title="2.2 导出为csv文件"></a>2.2 导出为csv文件</h3><p><strong>注意</strong>：这次启动方式<strong>不是neo4j start</strong>而是<strong>neo4j console</strong>，而只有这种启动才能顺利使用apoc</p><p>neo4j官方只能导出数据为dump或stream，而apoc让我们有了更多选择。</p><p><a href="https://neo4j.com/docs/apoc/current/export/csv/">apoc.export.csv</a></p><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">CALL apoc.export.csv.all(&quot;movies.csv&quot;, &#123;&#125;)&#x2F;&#x2F; 短短一句，就可将你的全部nodes和relationships导出成一个csv文件&#x2F;&#x2F; 而由于我们在apoc.conf文件中第三条设置为TRUE，所以导出的文件将位于noe4j的import文件夹下&#x2F;&#x2F; 当然你也可以将设置改为false，并且给出文件的绝对路径，来自定义文件的导出位置&#x2F;&#x2F; 注意！！修改设置后noe4j可以在你电脑上任意位置输出文件，注意文件导出地址安全性，别写在不该写的地方！               CALL apoc.export.csv.all(null, &#123;stream:true&#125;)&#x2F;&#x2F; 这样你的文件将导出成一个stream                      MATCH (person:Person)WHERE person.name STARTS WITH &quot;L&quot;WITH collect(person) AS peopleCALL apoc.export.csv.data(people, [], &quot;movies-l.csv&quot;, &#123;&#125;)YIELD file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, dataRETURN file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data&#x2F;&#x2F; 这样，我们就可以选择性的导出nodes&#x2F;&#x2F; 同时，我们注意到 apoc.export.csv.data第一个参数为nodes，第二个其实是relationships&#x2F;&#x2F; 而哪怕这里不导出关系，我们依旧要写一个[]保留位置，就和config参数的&#123;&#125;一样                MATCH (person:Person)-[actedIn:ACTED_IN]-&gt;(movie:Movie)WITH collect(DISTINCT person) AS people, collect(DISTINCT movie) AS movies, collect(actedIn) AS actedInRelsCALL apoc.export.csv.data(people + movies, actedInRels, &quot;movies-actedIn.csv&quot;, &#123;&#125;)YIELD file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, dataRETURN file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data&#x2F;&#x2F; 我们选择性的导出了nodes和relationships                           WITH &quot;MATCH path &#x3D; (person:Person)-[:DIRECTED]-&gt;(movie)      RETURN person.name AS name, person.born AS born,             movie.title AS title, movie.tagline AS tagline, movie.released AS released&quot; AS queryCALL apoc.export.csv.query(query, &quot;movies-directed.csv&quot;, &#123;&#125;)YIELD file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, dataRETURN file, source, format, nodes, relationships, properties, time, rows, batchSize, batches, done, data;&#x2F;&#x2F;这是一个与之前不同的方法，在这里我们传入的不是nodes或relationships，而是一个语句，这样子看上去简单多了                </code></pre></div></figure><p>大家或许注意到了，上述许多语句{}中的内容不是stream:true就是空的，其实，这里面可以设置很多配置</p><p>如下所示：</p><p><img src="https://s2.loli.net/2023/08/09/unIXg3w9VOToxEN.png" alt="image-20230808204348546"></p><p><strong>但是</strong>，其中的<strong>bulkImport</strong>设置只有在all和graph情况下才能生效：</p><p><img src="https://s2.loli.net/2023/08/09/pvPhyGdFDw8fBoT.png" alt="image-20230808204725076"></p><p>&nbsp;</p><h3 id="2-3导出为json文件"><a href="#2-3导出为json文件" class="headerlink" title="2.3导出为json文件"></a>2.3导出为json文件</h3><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">&#x2F;&#x2F; 基本与csv相同CALL apoc.export.json.all(&quot;all.json&quot;,&#123;useTypes:true&#125;)&#x2F;&#x2F; useTypes参数表明输出时是否表明type类型是node还是relationship</code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#x2F;&#x2F; out&#123;&quot;type&quot;:&quot;node&quot;,&quot;id&quot;:&quot;0&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;born&quot;:&quot;2015-07-04T19:32:24&quot;,&quot;name&quot;:&quot;Adam&quot;,&quot;place&quot;:&#123;&quot;crs&quot;:&quot;wgs-84&quot;,&quot;latitude&quot;:13.1,&quot;longitude&quot;:33.46789,&quot;height&quot;:null&#125;,&quot;age&quot;:42,&quot;male&quot;:true,&quot;kids&quot;:[&quot;Sam&quot;,&quot;Anna&quot;,&quot;Grace&quot;]&#125;&#125;&#123;&quot;type&quot;:&quot;node&quot;,&quot;id&quot;:&quot;1&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;name&quot;:&quot;Jim&quot;,&quot;age&quot;:42&#125;&#125;&#123;&quot;type&quot;:&quot;node&quot;,&quot;id&quot;:&quot;2&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;age&quot;:12&#125;&#125;&#123;&quot;id&quot;:&quot;0&quot;,&quot;type&quot;:&quot;relationship&quot;,&quot;label&quot;:&quot;KNOWS&quot;,&quot;properties&quot;:&#123;&quot;bffSince&quot;:&quot;P5M1DT12H&quot;,&quot;since&quot;:1993&#125;,&quot;start&quot;:&#123;&quot;id&quot;:&quot;0&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;born&quot;:&quot;2015-07-04T19:32:24&quot;,&quot;name&quot;:&quot;Adam&quot;,&quot;place&quot;:&#123;&quot;crs&quot;:&quot;wgs-84&quot;,&quot;latitude&quot;:13.1,&quot;longitude&quot;:33.46789,&quot;height&quot;:null&#125;,&quot;age&quot;:42,&quot;male&quot;:true,&quot;kids&quot;:[&quot;Sam&quot;,&quot;Anna&quot;,&quot;Grace&quot;]&#125;&#125;,&quot;end&quot;:&#123;&quot;id&quot;:&quot;1&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;name&quot;:&quot;Jim&quot;,&quot;age&quot;:42&#125;&#125;&#125;</code></pre></div></figure><p>&nbsp;</p><h3 id="2-4导出为Cypher语句"><a href="#2-4导出为Cypher语句" class="headerlink" title="2.4导出为Cypher语句"></a>2.4导出为Cypher语句</h3><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">CALL apoc.export.cypher.schema()YIELD format, time, cypherStatementsRETURN format, time, cypherStatements;&#x2F;&#x2F; 也与csv大同小异，多了一个schema，这个就支持导出索引以及所有的限制条件的建立，而不仅仅是一些数据</code></pre></div></figure><p>&nbsp;</p><h3 id="2-5导出为graphml文件"><a href="#2-5导出为graphml文件" class="headerlink" title="2.5导出为graphml文件"></a>2.5导出为graphml文件</h3><blockquote><p><em>The export GraphML procedures export data into a format that’s used by other tools like Gephi and CytoScape to read graph data.</em></p><p>主要是导出给Gephi 使用</p></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">&#x2F;&#x2F; examplecall apoc.export.graphml.query(&#39;MATCH (start:Foo)-[:KNOWS]-&gt;(:Bar) RETURN start&#39;, &#39;queryNodesFoo.graphml&#39;, &#123;useTypes: true&#125;);        </code></pre></div></figure><figure><div class="code-wrapper"><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;!-- out --&gt;&lt;?xml version&#x3D;&#39;1.0&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt;&lt;graphml xmlns&#x3D;&quot;http:&#x2F;&#x2F;graphml.graphdrawing.org&#x2F;xmlns&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;graphml.graphdrawing.org&#x2F;xmlns http:&#x2F;&#x2F;graphml.graphdrawing.org&#x2F;xmlns&#x2F;1.0&#x2F;graphml.xsd&quot;&gt;&lt;key id&#x3D;&quot;born&quot; for&#x3D;&quot;node&quot; attr.name&#x3D;&quot;born&quot; attr.type&#x3D;&quot;string&quot;&#x2F;&gt;&lt;key id&#x3D;&quot;name&quot; for&#x3D;&quot;node&quot; attr.name&#x3D;&quot;name&quot; attr.type&#x3D;&quot;string&quot;&#x2F;&gt;&lt;key id&#x3D;&quot;place&quot; for&#x3D;&quot;node&quot; attr.name&#x3D;&quot;place&quot; attr.type&#x3D;&quot;string&quot;&#x2F;&gt;&lt;key id&#x3D;&quot;labels&quot; for&#x3D;&quot;node&quot; attr.name&#x3D;&quot;labels&quot; attr.type&#x3D;&quot;string&quot;&#x2F;&gt;&lt;graph id&#x3D;&quot;G&quot; edgedefault&#x3D;&quot;directed&quot;&gt;&lt;node id&#x3D;&quot;n0&quot; labels&#x3D;&quot;:Foo:Foo0:Foo2&quot;&gt;&lt;data key&#x3D;&quot;labels&quot;&gt;:Foo:Foo0:Foo2&lt;&#x2F;data&gt;&lt;data key&#x3D;&quot;born&quot;&gt;2018-10-10&lt;&#x2F;data&gt;&lt;data key&#x3D;&quot;name&quot;&gt;foo&lt;&#x2F;data&gt;&lt;data key&#x3D;&quot;place&quot;&gt;&#123;&quot;crs&quot;:&quot;wgs-84-3d&quot;,&quot;latitude&quot;:12.78,&quot;longitude&quot;:56.7,&quot;height&quot;:100.0&#125;&lt;&#x2F;data&gt;&lt;&#x2F;node&gt;&lt;node id&#x3D;&quot;n3&quot; labels&#x3D;&quot;:Foo&quot;&gt;&lt;data key&#x3D;&quot;labels&quot;&gt;:Foo&lt;&#x2F;data&gt;&lt;data key&#x3D;&quot;name&quot;&gt;zzz&lt;&#x2F;data&gt;&lt;&#x2F;node&gt;&lt;node id&#x3D;&quot;n5&quot; labels&#x3D;&quot;:Foo&quot;&gt;&lt;data key&#x3D;&quot;labels&quot;&gt;:Foo&lt;&#x2F;data&gt;&lt;data key&#x3D;&quot;name&quot;&gt;aaa&lt;&#x2F;data&gt;&lt;&#x2F;node&gt;&lt;&#x2F;graph&gt;&lt;&#x2F;graphml&gt;</code></pre></div></figure><p>&nbsp;</p><p>&nbsp;</p><blockquote><p>apoc-extended 的导入还支持导入excel文件，但是不能是最新的5.10版本的neo4j。</p></blockquote><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="3-利用apoc在线导入"><a href="#3-利用apoc在线导入" class="headerlink" title="3.利用apoc在线导入"></a>3.利用apoc在线导入</h2><hr><p><a href="https://neo4j.com/docs/apoc/current/">apoc-core</a></p><p><a href="https://neo4j.com/labs/apoc/5/">apoc-extended</a></p><h3 id="3-1-从Web-APIs导入"><a href="#3-1-从Web-APIs导入" class="headerlink" title="3.1 从Web-APIs导入"></a>3.1 从Web-APIs导入</h3><blockquote><p><em>As <code>apoc.import.file.use_neo4j_config</code> is enabled, the procedures check whether file system access is allowed and possibly constrained to a specific directory by reading the two configuration parameters <code>dbms.security.allow_csv_import_from_file_urls</code> and <code>server.directories.import</code> respectively. If you want to remove these constraints please set <code>apoc.import.file.use_neo4j_config=false</code></em></p></blockquote><p>如果 <code>apoc.import.file.use_neo4j_config</code>设置为true，文件写入可能会有所限制。可以设为false，但是要注意安全性。</p><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">&#x2F;&#x2F; example，可以用url导入数据CALL apoc.load.xml(&#39;http:&#x2F;&#x2F;example.com&#x2F;test.xml&#39;, [&#39;xPath&#39;], [config]) YIELD value as doc CREATE (p:Person) SET p.name &#x3D; doc.name  &#x2F;&#x2F; 还可以从google cloud storage导入数据导入数据，但是要另外加一堆插件</code></pre></div></figure><p>&nbsp;</p><h3 id="3-2-load-csv文件"><a href="#3-2-load-csv文件" class="headerlink" title="3.2 load csv文件"></a>3.2 load csv文件</h3><p>这是需安装apoc-extended，比较实用，提一下。</p><blockquote><ul><li>provide a line number</li><li>provide both a map and a list representation of each line</li><li>automatic data conversion (including split into arrays)</li><li>option to keep the original string formatted values</li><li>ignoring fields (makes it easier to assign a full line as properties)</li><li>headerless files</li><li>replacing certain values with null</li></ul></blockquote><p> 上述便是apoc在load csv方面相对官方方法的改进</p><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">CALL apoc.load.csv(&#39;test.csv&#39;)YIELD lineNo, map, listRETURN *;CALL apoc.load.csv(&#123;url&#125;) yield map as row return rowCREATE (p:Person) SET p &#x3D; row</code></pre></div></figure><p>多种配置任你选择：</p><p><img src="https://s2.loli.net/2023/08/09/Ln6vM7k2oIEURwm.png" alt="image-20230809102037522"></p><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">CALL apoc.load.csv(&#39;test.csv&#39;, &#123;skip:1, limit:1, header:true, ignore:[&#39;name&#39;],   mapping:&#123;     age: &#123;type:&#39;int&#39;&#125;,     beverage: &#123;array:true, arraySep:&#39;;&#39;, name:&#39;drinks&#39;&#125;   &#125;&#125;)YIELD lineNo, map, listRETURN *;&#x2F;&#x2F; 其中地一个设置是针对文件的，第二个是针对读入的map</code></pre></div></figure><p>&nbsp;</p><h3 id="3-3-导入excel文件"><a href="#3-3-导入excel文件" class="headerlink" title="3.3 导入excel文件"></a>3.3 导入excel文件</h3><p>这个是在安装apoc-extended基础下的，因为比较常用了，稍微提一下。但是因为支持该功能的文件太大了，所以apoc将其分离出去了，你需另外下载支持文件安装到plugins文件夹下。</p><blockquote><p>For loading XLS we’re using the Apache POI library, which works well with old and new Excel formats, but is quite large. That’s why we decided not to include it into the apoc jar, but make it an optional dependency.</p><p>These dependencies are included in <a href="https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/download/5.9.0/apoc-xls-dependencies-5.9.0-all.jar">apoc-xls-dependencies-5.9.0-all.jar</a>, which can be downloaded from the <a href="https://github.com/neo4j-contrib/neo4j-apoc-procedures/releases/tag/5.9.0">releases page</a>. Once that file is downloaded, it should be placed in the <code>plugins</code> directory and the Neo4j Server restarted.</p><p><strong>Alternatively</strong>, you can download these jars from Maven Repository (putting them into <code>plugins</code> directory as well):</p><p>For XLS files:</p><ul><li><a href="https://repo1.maven.org/maven2/org/apache/poi/poi/5.1.0/poi-5.1.0.jar">poi-5.1.0.jar</a></li></ul><p>Additional for XLSX files:</p><ul><li><a href="https://repo1.maven.org/maven2/org/apache/commons/commons-collections4/4.4/commons-collections4-4.4.jar">commons-collections4-4.4.jar</a></li><li><a href="https://repo1.maven.org/maven2/org/apache/poi/poi-ooxml/5.1.0/poi-ooxml-5.1.0.jar">poi-ooxml-5.1.0.jar</a></li><li><a href="https://repo1.maven.org/maven2/org/apache/poi/poi-ooxml-lite/5.1.0/poi-ooxml-lite-5.1.0.jar">poi-ooxml-lite-5.1.0.jar</a></li><li><a href="https://repo1.maven.org/maven2/org/apache/xmlbeans/xmlbeans/5.0.2/xmlbeans-5.0.2.jar">xmlbeans-5.0.2.jar</a></li><li><a href="https://repo1.maven.org/maven2/com/github/virtuald/curvesapi/1.06/curvesapi-1.06.jar">curvesapi-1.06.jar</a></li></ul></blockquote><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">&#x2F;&#x2F; 同样简单明了CALL apoc.load.xls(&#123;url&#125;, &#123;Name of sheet&#125;, &#123;config&#125;)   &#x2F;&#x2F; 这里是&#39;Full&#39;,整个文件全导入CALL apoc.load.xls(&#39;file:&#x2F;&#x2F;&#x2F;path&#x2F;to&#x2F;file.xls&#39;,&#39;Full&#39;,&#123;mapping:&#123;Integer:&#123;type:&#39;int&#39;&#125;, Array:&#123;type:&#39;int&#39;,array:true,arraySep:&#39;;&#39;&#125;&#125;&#125;)                                                               &#x2F;&#x2F; 至于导入后再怎么处理，其实就和导入csv后处理一样，官方文档看一下load csv相关文档即可</code></pre></div></figure><p>config格式如下：</p><p><img src="https://s2.loli.net/2023/08/09/XZM1UFAmkbGdew7.png" alt="image-20230809103254865"></p><p>&nbsp;</p><h3 id="3-4-import-csv文件"><a href="#3-4-import-csv文件" class="headerlink" title="3.4 import csv文件"></a>3.4 import csv文件</h3><p>在apoc中，<strong>load</strong>和<strong>import</strong>其实是有一定区别的。</p><p><strong>load</strong>是导入neo4j类似缓存中，可以做后续操作后再导入neo4j数据库中（当然，也可以不导入）</p><p><strong>import</strong>是运行后就将数据存储入数据库中。</p><p>&nbsp;</p><p>而在apoc-core官方文档中提到：只要是满足apoc的csv文件格式规则的，就可以使用 <code>apoc.import.csv</code>来导入数据，但是对于大型数据，他们更推荐官方的import方式。（就是上文提到的终端下的 <code>neo4j-admin database import</code>）</p><p>&nbsp;</p><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">&#x2F;&#x2F; apoc.import.csv(&lt;nodes&gt;, &lt;relationships&gt;, &lt;config&gt;)&#x2F;&#x2F; 其中nodes和relationships都是以list，即[]的形式传入&#x2F;&#x2F; 而list中单个node或relationship又以map的形式传入&#x2F;&#x2F; &lt;nodes&gt;: [&#123;fileName: &#39;file:&#x2F;persons.csv&#39;, labels: [&#39;Teacher&#39;,&#39;Student&#39;]&#125;]&#x2F;&#x2F; 传入文件，以及文件中所含的标签&#x2F;&#x2F; &lt;relationships&gt;: [&#123;fileName:&#39;file:&#x2F;...&#39;,type:&#39;KNOWS&#39;&#125;]&#x2F;&#x2F; 传入文件以及关系的type&#x2F;&#x2F;注意！！map的关键字（key）一定要严格按照上方写，fileName写成filename就会出错！！&#x2F;&#x2F; exampleCALL apoc.import.csv(  [&#123;fileName: &#39;file:&#x2F;persons.csv&#39;, labels: [&#39;Person&#39;]&#125;],  [&#123;fileName: &#39;file:&#x2F;knows.csv&#39;, type: &#39;KNOWS&#39;&#125;],  &#123;delimiter: &#39;|&#39;, arrayDelimiter: &#39;,&#39;, stringIds: false&#125;)</code></pre></div></figure><p>config中可选配置如下：</p><p><img src="https://s2.loli.net/2023/08/20/eAjxtrqD2yCGz68.png" alt="image-20230812113109487"></p><p>&nbsp;</p><h3 id="3-5-导入json文件"><a href="#3-5-导入json文件" class="headerlink" title="3.5 导入json文件"></a>3.5 导入json文件</h3><ul><li><strong>apoc.load.json()</strong></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">apoc.load.json(urlOrKeyOrBinary :: ANY?, path &#x3D;  :: STRING?, config &#x3D; &#123;&#125; :: MAP?) :: (value :: MAP?)&#x2F;&#x2F; apoc.load.json&#x2F;&#x2F; 其中的path可以使用jsonPath，来指定导入内容&#x2F;&#x2F;exampleCALL apoc.load.json(&quot;file:&#x2F;&#x2F;&#x2F;person.json&quot;)YIELD valueMERGE (p:Person &#123;name: value.name&#125;)SET p.age &#x3D; value.ageWITH p, valueUNWIND value.children AS childMERGE (c:Person &#123;name: child&#125;)MERGE (c)-[:CHILD_OF]-&gt;(p);</code></pre></div></figure><p>config:</p><p><img src="https://s2.loli.net/2023/08/20/KzAPO42uxgt8l3y.png" alt="image-20230815205853386"></p><ul><li><strong>apoc.import.json()</strong></li></ul><figure><div class="code-wrapper"><pre class="line-numbers language-cypher" data-language="cypher"><code class="language-cypher">apoc.import.json(urlOrBinaryFile Any, config Map&lt;String, Any&gt;)&#x2F;&#x2F; import和load不一样，load后是要将数据进行后续操作，不一定保存到数据库中&#x2F;&#x2F; import的作用就是将数据导入&#x2F;&#x2F; 而通过观察import的signature我们可以发现，它不接受path参数，&#x2F;&#x2F; 这意味着import只能整个文件导入，那么这个文件要求保持一定格式规范，最好是通过apoc导出的json文件</code></pre></div></figure><p>导入的json文件样例:</p><figure><div class="code-wrapper"><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;type&quot;:&quot;node&quot;,&quot;id&quot;:&quot;0&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;born&quot;:&quot;2015-07-04T19:32:24&quot;,&quot;name&quot;:&quot;Adam&quot;,&quot;place&quot;:&#123;&quot;crs&quot;:&quot;wgs-84&quot;,&quot;latitude&quot;:13.1,&quot;longitude&quot;:33.46789,&quot;height&quot;:null&#125;,&quot;age&quot;:42,&quot;male&quot;:true,&quot;kids&quot;:[&quot;Sam&quot;,&quot;Anna&quot;,&quot;Grace&quot;]&#125;&#125;&#123;&quot;type&quot;:&quot;node&quot;,&quot;id&quot;:&quot;1&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;name&quot;:&quot;Jim&quot;,&quot;age&quot;:42&#125;&#125;&#123;&quot;type&quot;:&quot;node&quot;,&quot;id&quot;:&quot;2&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;age&quot;:12&#125;&#125;&#123;&quot;id&quot;:&quot;0&quot;,&quot;type&quot;:&quot;relationship&quot;,&quot;label&quot;:&quot;KNOWS&quot;,&quot;properties&quot;:&#123;&quot;bffSince&quot;:&quot;P5M1DT12H&quot;,&quot;since&quot;:1993&#125;,&quot;start&quot;:&#123;&quot;id&quot;:&quot;0&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;born&quot;:&quot;2015-07-04T19:32:24&quot;,&quot;name&quot;:&quot;Adam&quot;,&quot;place&quot;:&#123;&quot;crs&quot;:&quot;wgs-84&quot;,&quot;latitude&quot;:13.1,&quot;longitude&quot;:33.46789,&quot;height&quot;:null&#125;,&quot;age&quot;:42,&quot;male&quot;:true,&quot;kids&quot;:[&quot;Sam&quot;,&quot;Anna&quot;,&quot;Grace&quot;]&#125;&#125;,&quot;end&quot;:&#123;&quot;id&quot;:&quot;1&quot;,&quot;labels&quot;:[&quot;User&quot;],&quot;properties&quot;:&#123;&quot;name&quot;:&quot;Jim&quot;,&quot;age&quot;:42&#125;&#125;&#125;</code></pre></div></figure><p>config：</p><p><img src="https://s2.loli.net/2023/08/20/kazcpEDhY3Iu69P.png" alt="image-20230819083810885"></p><p><img src="https://s2.loli.net/2023/08/20/Pgyr457X1MLF86Y.png" alt="image-20230819083839427"></p><p>&nbsp;</p><p>apoc-core还支持导入<strong>xml</strong>文件和<strong>graphml</strong>，与前面的json等基本一致，这里就不介绍了，大家可以看一下官方文档。</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><h2 id="4-复制数据库秘籍——复制文件夹大法"><a href="#4-复制数据库秘籍——复制文件夹大法" class="headerlink" title="4. 复制数据库秘籍——复制文件夹大法"></a>4. 复制数据库秘籍——复制文件夹大法</h2><p>当我们要将海量的数据从一个neo4j数据库导入另一台计算机的neo4j数据库时，如果采用上述的办法，或许要等非常长的时间。此时我们就可以直接复制文件。</p><p>具体步骤如下：</p><ol><li>假设我们<strong>被复制</strong>的数据库的名字为<strong>Data.db</strong>。</li><li>打开需要复制数据的电脑（即数据源）的 <strong>neo4j主目录&#x2F;data&#x2F;</strong> ，在其目录下有两个文件夹，<strong>databases</strong>和<strong>transactions</strong>。在这两个数据夹下各有一个<strong>Data.db</strong>文件夹，这就是neo4j的<strong>Data.db</strong>数据库存储的数据。</li><li>拷贝这两个文件夹到需要导入的电脑，放置在同样的目录下。<em><strong>注意！</strong></em>一定要放在同样的目录下，由于两个文件夹是同名的，所以注意别放错了地方。</li><li>新建database，我推荐是和<strong>被复制</strong>的数据库同名，即<strong>Data.db</strong>。这个我个人试过，肯定没问题。你也可以试试建一个<strong>myData.db</strong>，然后把那两个文件夹重命名为<strong>myData.db</strong>。</li></ol><p>提示：可能会在复制粘贴文件夹时提示无权限修改或权限不足一类的，linux操作系统可以在终端中使用 <code>sudo mv -i 所需复制的文件 目的地</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>neo4j</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu（22.04）中的常见问题及解决</title>
    <link href="/ubuntu%E4%B8%AD%E7%9A%84n%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/"/>
    <url>/ubuntu%E4%B8%AD%E7%9A%84n%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>&nbsp;</p><h2 id="chrome浏览器无法显示文本或显示不全"><a href="#chrome浏览器无法显示文本或显示不全" class="headerlink" title="chrome浏览器无法显示文本或显示不全"></a>chrome浏览器无法显示文本或显示不全</h2><hr><p><img src="https://s2.loli.net/2023/08/07/PVuB7JAeIwkogED.png" alt="img"></p><p><a href="https://askubuntu.com/questions/1469580/ubuntu-22-04-chrome-broswer-cant-see-any-text-or-image-content-after-update">Ask For Ubuntu</a></p><h3 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd ~&#x2F;.config&#x2F;google-chrome&#x2F;Defaultrm -rf GPUCache&#x2F;</code></pre></div></figure><p><strong>&nbsp;</strong></p><h2 id="腾讯会议提示由于窗口协议是“wayland”-所以无法使用"><a href="#腾讯会议提示由于窗口协议是“wayland”-所以无法使用" class="headerlink" title="腾讯会议提示由于窗口协议是“wayland”,所以无法使用"></a>腾讯会议提示由于窗口协议是“wayland”,所以无法使用</h2><hr><p><strong>version（3.15.0）</strong></p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 找到 &#x2F;opt&#x2F;wemeet&#x2F;wemeetapp.sh$ cd &#x2F;opt&#x2F;wemeet&#x2F;# 暂时改一下权限 $ sudo chmod 777 wemeetapp.sh#也可以直接记事本打开，主要是要编辑$ vim wemeetapp.sh# 找到  if [ &quot;$XDG_SESSION_TYPE&quot; &#x3D; &quot;wayland&quot; ];then  这一行‘’‘ 在这一行前面加上：export XDG_SESSION_TYPE&#x3D;x11export QT_QPA_PLATFORM&#x3D;xcbunset WAYLAND_DISPLAY保存后关闭’‘’# 安全起见，改回只读权限$ sudo chmod 444 wemeetapp.sh</code></pre></div></figure><p>2023.7.29</p><p>刚刚发现刚更新的3.15.1使用上述方法后会出现图标消失，点击无反映的问题，目前未找到解决办法。我直接回退到3.15.0用老办法，等大佬提出解决办法再解决吧</p><p>&nbsp;</p><h2 id="unzip解压后中文文件名乱码"><a href="#unzip解压后中文文件名乱码" class="headerlink" title="unzip解压后中文文件名乱码"></a>unzip解压后中文文件名乱码</h2><hr><p><a href="https://www.zhihu.com/question/20523036">参考文章</a></p><p>这是因为unzip命令解压缩是默认使用<strong>utf-8</strong>编码，而文件可能使用了其他编码方式，导致文件名乱码</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ unzip -O cp936 filename.zip -d filedirname # 这里用了cp936编码，如果仍有乱码可以多试试其他编码或者去询问该文件分享者使用的压缩方式从而确定它的编码</code></pre></div></figure><p>&nbsp;</p><h2 id="ubuntu安装下载steam"><a href="#ubuntu安装下载steam" class="headerlink" title="ubuntu安装下载steam"></a>ubuntu安装下载steam</h2><hr><blockquote><p><em>（更新时间：2023-08-24）</em></p></blockquote><p>ubuntu安装下载steam主要有三种方式：</p><ol><li>snap安装</li><li>使用deb包安装（本人没试过此方法，这里不作具体介绍，deb包官网可获得）</li><li>使用apt安装（推荐）</li></ol><p>之所以推荐使用apt安装是因为它的更新管理十分方便:</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 终端执行下面两条指令即可更新升级你用apt下载的所有软件包了$ sudo apt update$ sudo apt upgrade</code></pre></div></figure><p><strong>但是</strong>，要注意steam的apt安装不是简单的 <code>sudo apt install steam</code>，这可能会存在依赖丢失，更新时公钥缺失的问题，下文介绍的apt安装方法是steam官方提供的方法。</p><p>接下来，我就来介绍这三种下载方法</p><h3 id="1-snap安装"><a href="#1-snap安装" class="headerlink" title="1.snap安装"></a>1.snap安装</h3><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 打开终端$ sudo snap install steam</code></pre></div></figure><p>当然，你可以使用ubuntu 22.04上的<strong>图形化界面（ubuntu software）</strong>来下载安装。</p><p>其实使用snap安装是最快的安装方式，但是，snap本身在ubuntu用户中并不是十分常用，它具有一些软件包大启动缓慢等问题。</p><p>而<strong>snap</strong>中的steam版本是<strong>1.0.0.76</strong>，<strong>apt</strong>中是<strong>1.0.0.78</strong>，apt上的版本也要更加新一些。</p><h3 id="2-apt安装"><a href="#2-apt安装" class="headerlink" title="2.apt安装"></a>2.apt安装</h3><p>参考了<a href="https://repo.steampowered.com/steam/">steam官方apt下载方法</a></p><p>下载<a href="https://repo.steampowered.com/steam/archive/stable/steam.gpg">steam.gpg</a>文件，并将其放置于*&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;steam.gpg*</p><p>接下来，打开终端执行如下操作：</p><figure><div class="code-wrapper"><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;steam-stable.list &lt;&lt;&#39;EOF&#39;# 此命令是向steam-stable.list文件追加内容deb [arch&#x3D;amd64,i386 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;steam.gpg] https:&#x2F;&#x2F;repo.steampowered.com&#x2F;steam&#x2F; stable steamdeb-src [arch&#x3D;amd64,i386 signed-by&#x3D;&#x2F;usr&#x2F;share&#x2F;keyrings&#x2F;steam.gpg] https:&#x2F;&#x2F;repo.steampowered.com&#x2F;steam&#x2F; stable steamEOF# 这是追加的内容$ sudo dpkg --add-architecture i386$ sudo apt-get update$ sudo apt-get install \  libgl1-mesa-dri:amd64 \  libgl1-mesa-dri:i386 \  libgl1-mesa-glx:amd64 \  libgl1-mesa-glx:i386 \  steam-launcher</code></pre></div></figure><p>安装完成，打开steam设置的兼容性开启为所有产品使用steam play，你就可以获得与windows下几乎一样的游戏体验！</p><p>（ps ：有谁知道ubuntu除了复制粘贴怎么在steam客户端及游戏中输入中文的可以在评论区分享一下，谢谢！）</p>]]></content>
    
    
    
    <tags>
      
      <tag>ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
